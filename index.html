<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CornerPXL Intelligence</title>
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <div class="wrap">
      <div class="hero">
        <h1 class="title">CornerPXL Intelligence</h1>
        <p class="subtitle">Paste links + upload context to generate brand, market, and strategy reports.</p>
      </div>

      <div class="panel">
        <form id="form">
          <div class="row">
            <div class="field">
              <div class="label">Website Link</div>
              <input class="input" type="url" name="websiteLink" id="websiteLink" placeholder="https://example.com" required />
              <div class="errorMsg hidden" id="websiteLinkError"></div>
            </div>
            <div class="field">
              <div class="label">LinkedIn Link</div>
              <input class="input" type="url" name="linkedinLink" id="linkedinLink" placeholder="https://linkedin.com/in/..." required />
              <div class="errorMsg hidden" id="linkedinLinkError"></div>
            </div>
          </div>

          <div class="drop" id="dropzone">
            <div class="dropInner">
              <div class="icon" aria-hidden="true">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
                  <path d="M12 3v10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M8 7l4-4 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M4 14v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
              </div>

              <p class="dropTitle">Drop files here</p>
              <p class="dropMeta">Supported formats: PDF, DOCX, TXT • Max size: 50MB per file • Up to 5 files</p>

              <div class="fileLine hidden" id="fileLine"></div>
              <div class="browse" id="browseBtn">Browse files</div>
            </div>

            <!-- IMPORTANT: field name is "file" -->
            <input id="fileInput" type="file" name="file" multiple accept=".pdf,.docx,.txt,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document,text/plain" />
          </div>

          <button id="analyzeBtn" class="cta" type="submit">
            <span id="ctaIcon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M12 3v10" stroke="white" stroke-width="2" stroke-linecap="round"/>
                <path d="M8 11l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M4 20h16" stroke="white" stroke-width="2" stroke-linecap="round"/>
              </svg>
            </span>
            <span id="ctaText">Generate Reports</span>
          </button>
        </form>
      </div>

      <div class="loadingInfo hidden" id="loadingInfo">
        <p>Usually takes up to 10 mins</p>
      </div>

      <div class="mini">
        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M12 3v10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M8 7l4-4 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 14v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </div>
          <h4>Easy Upload</h4>
          <p>Add a website link, optional LinkedIn, and any supporting files.</p>
        </div>

        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            </svg>
          </div>
          <h4>Fast Processing</h4>
          <p>We analyze your inputs and generate research + strategy documents automatically.</p>
        </div>

        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
              <path d="M14 2v6h6" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            </svg>
          </div>
          <h4>Instant Download</h4>
          <p>Download your Brand Research, Market Research, and Strategy Document when ready.</p>
        </div>
      </div>
    </div>

    <!-- RESULT MODAL -->
    <div id="overlay" class="overlay" role="dialog" aria-modal="true">
      <div class="modal">
        <div class="modalHeader">
          <div id="badge" class="badge">✓</div>
          <h3 id="modalTitle" class="modalTitle">Success</h3>
        </div>
        <p id="modalText" class="modalText"></p>

        <div id="downloadLinks" class="links hidden"></div>

        <div class="actions">
          <button id="okBtn" class="btn btnPrimary" type="button">Done</button>
        </div>
      </div>
    </div>

    <!-- Load configuration from config.js (can be generated from .env) -->
    <script src="config.js"></script>
    <script>
      // Get webhook URL from config or use default
      // NOTE: Webhook URL will be visible in browser. For production, consider:
      // 1. Adding authentication to n8n webhook
      // 2. Using a server-side proxy
      const N8N_WEBHOOK_URL = window.APP_CONFIG?.N8N_WEBHOOK_URL || null;

      const form = document.getElementById("form");
      const dropzone = document.getElementById("dropzone");
      const fileInput = document.getElementById("fileInput");
      const browseBtn = document.getElementById("browseBtn");
      const fileLine = document.getElementById("fileLine");
      
      const websiteLinkInput = document.getElementById("websiteLink");
      const linkedinLinkInput = document.getElementById("linkedinLink");
      const websiteLinkError = document.getElementById("websiteLinkError");
      const linkedinLinkError = document.getElementById("linkedinLinkError");

      const overlay = document.getElementById("overlay");
      const analyzeBtn = document.getElementById("analyzeBtn");
      const ctaText = document.getElementById("ctaText");
      const ctaIcon = document.getElementById("ctaIcon");

      const badge = document.getElementById("badge");
      const modalTitle = document.getElementById("modalTitle");
      const modalText = document.getElementById("modalText");
      const downloadLinks = document.getElementById("downloadLinks");
      const okBtn = document.getElementById("okBtn");
      const loadingInfo = document.getElementById("loadingInfo");

      // ===== JOB-BASED FLOW: localStorage helpers =====
      const JOB_STORAGE_KEY_PREFIX = "cornerpxl_job_";
      const STATUS_CHECK_INTERVAL = 60000; // 1 minute
      const JOB_TTL_MS = 3600000; // 1 hour

      let statusCheckIntervalId = null;
      let isIntervalPaused = false;

      // Generate or retrieve unique tabId for this tab
      function getTabId() {
        try {
          let tabId = sessionStorage.getItem("cornerpxl_tabId");
          if (!tabId) {
            // Generate a unique ID for this tab
            tabId = `tab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            sessionStorage.setItem("cornerpxl_tabId", tabId);
          }
          return tabId;
        } catch (err) {
          console.warn("Failed to get tabId from sessionStorage:", err);
          // Fallback: generate a temporary ID (won't persist across reloads)
          return `tab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
      }

      function getJobStorageKey() {
        return JOB_STORAGE_KEY_PREFIX + getTabId();
      }

      function saveJob(jobObj) {
        try {
          const jobData = {
            jobId: jobObj.jobId,
            status: jobObj.status,
            createdAt: jobObj.createdAt,
            updatedAt: jobObj.updatedAt || jobObj.createdAt,
            lastCheckedAt: jobObj.lastCheckedAt || null,
            tabId: getTabId() // Store tabId in job data for verification
          };
          localStorage.setItem(getJobStorageKey(), JSON.stringify(jobData));
        } catch (err) {
          console.warn("Failed to save job to localStorage:", err);
        }
      }

      function loadJob() {
        try {
          const stored = localStorage.getItem(getJobStorageKey());
          if (!stored) return null;
          const job = JSON.parse(stored);
          // Verify tabId matches (in case of edge cases)
          if (job.tabId && job.tabId !== getTabId()) {
            console.warn("Job tabId mismatch, clearing job");
            clearJob();
            return null;
          }
          return job;
        } catch (err) {
          console.warn("Failed to load job from localStorage:", err);
          return null;
        }
      }

      function clearJob() {
        try {
          localStorage.removeItem(getJobStorageKey());
        } catch (err) {
          console.warn("Failed to clear job from localStorage:", err);
        }
      }

      // Cleanup old jobs from localStorage where createdAt to updatedAt difference > 1 hour
      function cleanupOldJobs() {
        try {
          const keysToRemove = [];
          
          // Scan all localStorage keys
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            
            // Check if this is a job key
            if (key && key.startsWith(JOB_STORAGE_KEY_PREFIX)) {
              try {
                const jobData = JSON.parse(localStorage.getItem(key));
                
                // Check if job has both createdAt and updatedAt
                if (jobData && jobData.createdAt && jobData.updatedAt) {
                  const createdAt = Date.parse(jobData.createdAt);
                  const updatedAt = Date.parse(jobData.updatedAt);
                  
                  // If timestamps are valid, check the difference
                  if (!isNaN(createdAt) && !isNaN(updatedAt)) {
                    const timeDiff = updatedAt - createdAt;
                    
                    // If difference is more than 1 hour, mark for removal
                    if (timeDiff > JOB_TTL_MS) {
                      keysToRemove.push(key);
                    }
                  }
                }
              } catch (parseErr) {
                // If we can't parse the job data, it's corrupted - remove it
                console.warn("Found corrupted job data, removing:", key);
                keysToRemove.push(key);
              }
            }
          }
          
          // Remove old jobs
          keysToRemove.forEach(key => {
            try {
              localStorage.removeItem(key);
              console.log("Removed old job:", key);
            } catch (err) {
              console.warn("Failed to remove old job:", key, err);
            }
          });
          
          if (keysToRemove.length > 0) {
            console.log(`Cleanup completed: removed ${keysToRemove.length} old job(s)`);
          }
        } catch (err) {
          console.warn("Failed to cleanup old jobs:", err);
        }
      }

      function isJobExpired(job) {
        if (!job || !job.updatedAt) return true;
        const updatedAt = Date.parse(job.updatedAt);
        if (isNaN(updatedAt)) return true;
        return (Date.now() - updatedAt) > JOB_TTL_MS;
      }

      // ===== STATUS CHECKING =====
      async function checkJobStatusOnce(jobId) {
        if (!N8N_WEBHOOK_URL || !jobId) {
          console.warn("Cannot check status: missing webhook URL or jobId");
          return null;
        }

        try {
          const response = await fetch(N8N_WEBHOOK_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ jobId }),
            mode: "cors",
            credentials: "omit"
          });

          if (!response.ok) {
            throw new Error(`Status check failed: ${response.status}`);
          }

          const data = await response.json();
          
          // n8n returns a single object (or array with one object - handle both)
          let item;
          if (Array.isArray(data)) {
            if (data.length === 0) {
              console.warn("Invalid status response format: empty array");
              return null;
            }
            item = data[0];
          } else if (data && typeof data === 'object') {
            item = data;
          } else {
            console.warn("Invalid status response format");
            return null;
          }

          if (!item.jobId || item.jobId !== jobId) {
            console.warn("JobId mismatch in status response");
            return null;
          }

          // Update localStorage with latest status
          const currentJob = loadJob();
          if (currentJob && currentJob.jobId === jobId) {
            saveJob({
              ...currentJob,
              status: item.status,
              updatedAt: item.updatedAt || new Date().toISOString(),
              lastCheckedAt: new Date().toISOString()
            });
          }

          return item;
        } catch (err) {
          // Network errors: keep job and retry next interval
          console.warn("Status check failed (will retry):", err.message);
          return null; // Return null to indicate transient error
        }
      }

      function mapResultNameToDisplayName(name) {
        if (name === 'brandResearch') return 'Brand Research';
        if (name === 'marketResearch') return 'Market Research';
        if (name === 'strategyBrief') return 'Strategy Brief';
        return name;
      }

      function handleJobStatusUpdate(item) {
        if (!item) return; // Transient error, will retry

        const status = item.status;

        if (status === "completed") {
          // Stop interval
          stopStatusInterval();
          
          // Extract results
          if (item.results && item.results.ok === true && Array.isArray(item.results.results)) {
            // Map results to links format
            const links = item.results.results.map((result) => {
              const displayName = mapResultNameToDisplayName(result.name || result.filename);
              return {
                name: displayName || `Report`,
                url: result.url
              };
            });

            // Show success modal with links (keep localStorage until Done click)
            showModal({
              ok: true,
              text: links.length > 0 
                ? `Done! ${links.length} report${links.length > 1 ? 's' : ''} ${links.length > 1 ? 'are' : 'is'} ready.`
                : "Done! Your reports have been processed.",
              links: links
            });
          } else {
            // Completed but no results - treat as error
            showModal({
              ok: false,
              text: "Job completed but no results were returned. Please try again."
            });
            clearJob();
          }
          
          setLoading(false);
        } else if (status === "failed") {
          // Stop interval
          stopStatusInterval();
          
          // Extract error message
          let errorText = "Job failed. Please try again.";
          if (item.error) {
            if (typeof item.error === "string") {
              errorText = item.error;
            } else if (item.error.message) {
              errorText = item.error.message;
            }
          }
          
          // Show error modal and clear localStorage immediately
          showModal({
            ok: false,
            text: errorText
          });
          
          clearJob();
          setLoading(false);
        } else if (status === "processing" || status === "pending") {
          // Keep loading, continue checking (pending is treated like processing)
          // Status already updated in localStorage
        } else {
          // Unknown status - treat as transient error
          console.warn("Unknown job status:", status);
        }
      }

      // ===== INTERVAL MANAGEMENT =====
      function startStatusInterval() {
        // Prevent multiple intervals
        if (statusCheckIntervalId !== null) {
          return;
        }

        const job = loadJob();
        if (!job || !job.jobId) {
          console.warn("Cannot start status interval: no job found");
          return;
        }

        // Check status immediately
        checkJobStatusOnce(job.jobId).then(handleJobStatusUpdate);

        // Then check every 30 seconds
        statusCheckIntervalId = setInterval(() => {
          if (isIntervalPaused) {
            return; // Skip if paused
          }

          const currentJob = loadJob();
          if (!currentJob || !currentJob.jobId) {
            stopStatusInterval();
            return;
          }

          // Check TTL
          if (isJobExpired(currentJob)) {
            stopStatusInterval();
            setLoading(false);
            clearJob();
            showModal({
              ok: false,
              text: "Job expired after 1 hour of inactivity. Please submit a new request."
            });
            return;
          }

          checkJobStatusOnce(currentJob.jobId).then(handleJobStatusUpdate);
        }, STATUS_CHECK_INTERVAL);
      }

      function stopStatusInterval() {
        if (statusCheckIntervalId !== null) {
          clearInterval(statusCheckIntervalId);
          statusCheckIntervalId = null;
        }
      }

      // ===== VISIBILITY HANDLING =====
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          // Tab hidden: pause interval (don't make requests)
          isIntervalPaused = true;
        } else {
          // Tab visible: resume interval
          isIntervalPaused = false;
          
          // If we have an active job, check status immediately
          const job = loadJob();
          if (job && (job.status === "processing" || job.status === "pending") && !isJobExpired(job)) {
            checkJobStatusOnce(job.jobId).then(handleJobStatusUpdate);
          }
        }
      });

      // ===== RESUME ON LOAD =====
      function resumeJobOnLoad() {
        const job = loadJob();
        if (!job || !job.jobId) {
          return; // No stored job
        }

        // Check if expired
        if (isJobExpired(job)) {
          clearJob();
          return;
        }

        // Check if terminal state
        if (job.status === "completed" || job.status === "failed") {
          // Terminal state: clear if failed, keep if completed (until Done click)
          if (job.status === "failed") {
            clearJob();
          }
          return;
        }

        // Resume processing job (pending is treated like processing)
        if (job.status === "processing" || job.status === "pending") {
          setLoading(true);
          startStatusInterval();
          // Immediately check status
          checkJobStatusOnce(job.jobId).then(handleJobStatusUpdate);
        }
      }

      // Call on page load
      window.addEventListener("load", () => {
        cleanupOldJobs(); // Clean up old jobs first
        resumeJobOnLoad();
      });

      // Also call immediately if DOM is already loaded
      if (document.readyState === "complete" || document.readyState === "interactive") {
        cleanupOldJobs(); // Clean up old jobs first
        resumeJobOnLoad();
      }

      function humanSize(bytes){
        const mb = bytes / (1024*1024);
        if (mb >= 1) return `${mb.toFixed(2)} MB`;
        const kb = bytes / 1024;
        return `${kb.toFixed(1)} KB`;
      }

      function isValidFileType(file){
        const allowedExtensions = ['.pdf', '.docx', '.txt'];
        const fileName = file.name.toLowerCase();
        return allowedExtensions.some(ext => fileName.endsWith(ext));
      }

      function isValidUrl(url, allowEmpty = false){
        if (!url || url.trim() === '') {
          return allowEmpty;
        }
        try {
          const urlObj = new URL(url);
          return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';
        } catch {
          return false;
        }
      }

      function isValidLinkedInUrl(url){
        if (!url || url.trim() === '') return false; // Required field
        const linkedinPattern = /^https?:\/\/(www\.)?linkedin\.com\/(in|company|school)\/.+/i;
        return linkedinPattern.test(url);
      }

      function showError(inputElement, errorElement, message){
        inputElement.classList.add('error');
        errorElement.textContent = message;
        errorElement.classList.remove('hidden');
      }

      function hideError(inputElement, errorElement){
        inputElement.classList.remove('error');
        errorElement.classList.add('hidden');
      }

      function validateWebsiteLink(){
        const value = websiteLinkInput.value.trim();
        if (!value) {
          showError(websiteLinkInput, websiteLinkError, 'Website link is required');
          return false;
        }
        if (!isValidUrl(value)) {
          showError(websiteLinkInput, websiteLinkError, 'Please enter a valid URL (e.g., https://example.com)');
          return false;
        }
        hideError(websiteLinkInput, websiteLinkError);
        return true;
      }

      function validateLinkedInLink(){
        const value = linkedinLinkInput.value.trim();
        if (!value) {
          showError(linkedinLinkInput, linkedinLinkError, 'LinkedIn link is required');
          return false;
        }
        if (!isValidUrl(value)) {
          showError(linkedinLinkInput, linkedinLinkError, 'Please enter a valid URL');
          return false;
        }
        if (!isValidLinkedInUrl(value)) {
          showError(linkedinLinkInput, linkedinLinkError, 'Please enter a valid LinkedIn URL (e.g., https://linkedin.com/in/username)');
          return false;
        }
        hideError(linkedinLinkInput, linkedinLinkError);
        return true;
      }

      function removeFile(indexToRemove){
        const files = fileInput.files;
        if (!files || files.length === 0) return;
        
        const dt = new DataTransfer();
        Array.from(files).forEach((file, index) => {
          if (index !== indexToRemove) {
            dt.items.add(file);
          }
        });
        fileInput.files = dt.files;
        setFileLine(fileInput.files);
      }

      function setFileLine(files){
        if (!files || files.length === 0){ 
          fileLine.classList.add("hidden"); 
          fileLine.innerHTML=""; 
          return; 
        }
        
        // Check file count limit
        if (files.length > 5) {
          fileLine.classList.remove("hidden");
          fileLine.innerHTML = `<span style="color: var(--error);">Maximum 5 files allowed. Please select fewer files.</span>`;
          fileInput.value = ''; // Clear the files
          return;
        }
        
        // Validate all files
        const invalidFiles = Array.from(files).filter(file => !isValidFileType(file));
        if (invalidFiles.length > 0) {
          fileLine.classList.remove("hidden");
          fileLine.innerHTML = `<span style="color: var(--error);">Unsupported file type: ${invalidFiles[0].name}. Please upload PDF, DOCX, or TXT files only.</span>`;
          fileInput.value = ''; // Clear the invalid files
          return;
        }
        
        // Display all files with remove buttons
        fileLine.classList.remove("hidden");
        const filesList = Array.from(files).map((file, index) => 
          `<div class="fileItem" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; padding: 6px 8px; background: rgba(173,216,230,0.1); border-radius: 8px;">
            <span>${index + 1}. ${file.name} <span style="color: var(--muted);">(${humanSize(file.size)})</span></span>
            <button type="button" class="removeFileBtn" data-index="${index}" aria-label="Remove file" style="background: none; border: none; color: var(--error); cursor: pointer; padding: 4px 8px; font-size: 18px; font-weight: 900; line-height: 1;">×</button>
          </div>`
        ).join('');
        fileLine.innerHTML = `<div style="text-align: left;">${filesList}</div>`;
        
        // Add event listeners to remove buttons
        fileLine.querySelectorAll('.removeFileBtn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const index = parseInt(btn.getAttribute('data-index'));
            removeFile(index);
          });
        });
      }

      function base64ToBlob(base64, mimeType = "application/pdf"){
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++){
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
      }

      function downloadBlob(blob, filename){
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      async function downloadFromUrl(url, filename){
        try {
          // Download from webhook
          // Webhook handles file access server-side and returns the file
          const response = await fetch(url, {
            method: 'POST',
            mode: 'cors',
            credentials: 'omit',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (!response.ok) {
            const errorText = await response.text().catch(() => '');
            console.error('Download failed:', response.status, errorText);
            
            if (response.status === 404) {
              showModal({ 
                ok: false, 
                text: `File not found: "${filename}". The file may have been moved or deleted.` 
              });
              return;
            }
            
            if (response.status === 403) {
              showModal({ 
                ok: false, 
                text: `Access denied: Unable to download "${filename}". Please contact support.` 
              });
              return;
            }
            
            throw new Error(`Failed to fetch: ${response.status}`);
          }
          
          // Get the blob and download
          const blob = await response.blob();
          downloadBlob(blob, filename);
          
        } catch (err) {
          console.error('Download error:', err);
          
          // Show user-friendly error message
          showModal({ 
            ok: false, 
            text: `Unable to download "${filename}": ${err.message || 'Network error'}. Please try again or contact support.` 
          });
        }
      }

      function setLoading(isLoading){
        analyzeBtn.disabled = isLoading;
        
        // Disable/enable all form inputs
        websiteLinkInput.disabled = isLoading;
        linkedinLinkInput.disabled = isLoading;
        fileInput.disabled = isLoading;
        
        // Disable dropzone interactions
        if (isLoading) {
          dropzone.style.pointerEvents = 'none';
          dropzone.style.opacity = '0.6';
        } else {
          dropzone.style.pointerEvents = 'auto';
          dropzone.style.opacity = '1';
        }
        
        // Show/hide loading info message
        if (loadingInfo) {
          if (isLoading) {
            loadingInfo.classList.remove('hidden');
            loadingInfo.style.display = 'block';
          } else {
            loadingInfo.classList.add('hidden');
            loadingInfo.style.display = 'none';
          }
        }
        
        if (isLoading){
          ctaText.textContent = "Analyzing...";
          ctaIcon.innerHTML = '<div class="spinner" aria-hidden="true"></div>';
        } else {
          ctaText.textContent = "Generate Reports";
          ctaIcon.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
              <path d="M12 3v10" stroke="white" stroke-width="2" stroke-linecap="round"/>
              <path d="M8 11l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 20h16" stroke="white" stroke-width="2" stroke-linecap="round"/>
            </svg>`;
        }
      }

      function showModal({ ok, text, links }){
        overlay.classList.add("show");
        badge.className = "badge";
        if (ok){
          badge.textContent = "✓";
          badge.classList.add("success");
          modalTitle.textContent = "Success";
          modalText.textContent = text || "Your reports are ready.";
        } else {
          badge.textContent = "!";
          badge.classList.add("error");
          modalTitle.textContent = "Error";
          modalText.textContent = text || "Something went wrong.";
        }

        downloadLinks.innerHTML = "";
        if (Array.isArray(links) && links.length){
          downloadLinks.classList.remove("hidden");
          links.forEach((r, index) => {
            const a = document.createElement("a");
            a.className = "linkBtn";
            const filename = r.name || `report-${index + 1}.pdf`;
            const url = r.url;
            
            // Handle click to force download
            a.addEventListener("click", async (e) => {
              e.preventDefault();
              
              // If it's already a blob URL, download directly
              if (url.startsWith('blob:')) {
                const response = await fetch(url);
                const blob = await response.blob();
                downloadBlob(blob, filename);
                return;
              }
              
              // For external URLs, fetch and download
              await downloadFromUrl(url, filename);
            });
            
            a.href = url;
            a.download = filename;
            a.rel = "noopener";
            a.innerHTML = `<span>${r.name || `Report ${index + 1}`}</span><small>Download</small>`;
            downloadLinks.appendChild(a);
          });
        } else {
          downloadLinks.classList.add("hidden");
        }
      }

      function resetFlow(){
        overlay.classList.remove("show");
        form.reset();
        setFileLine(null);
        setLoading(false);
        // Stop status checking interval
        stopStatusInterval();
        // Clear job from localStorage (user clicked Done)
        clearJob();
        // Clear validation errors
        hideError(websiteLinkInput, websiteLinkError);
        hideError(linkedinLinkInput, linkedinLinkError);
      }
      okBtn.addEventListener("click", resetFlow);

      // Link validation event listeners
      websiteLinkInput.addEventListener("blur", validateWebsiteLink);
      websiteLinkInput.addEventListener("input", () => {
        if (websiteLinkInput.classList.contains('error')) {
          validateWebsiteLink();
        }
      });

      linkedinLinkInput.addEventListener("blur", validateLinkedInLink);
      linkedinLinkInput.addEventListener("input", () => {
        if (linkedinLinkInput.classList.contains('error')) {
          validateLinkedInLink();
        }
      });

      browseBtn.addEventListener("click", (e) => { e.preventDefault(); fileInput.click(); });
      dropzone.addEventListener("click", (e) => {
        if (e.target?.closest?.("#browseBtn")) return;
        fileInput.click();
      });

      fileInput.addEventListener("change", () => setFileLine(fileInput.files || null));

      function prevent(e){ e.preventDefault(); e.stopPropagation(); }

      ["dragenter","dragover"].forEach(evt =>
        dropzone.addEventListener(evt, (e) => { prevent(e); dropzone.classList.add("dragover"); })
      );
      ["dragleave","drop"].forEach(evt =>
        dropzone.addEventListener(evt, (e) => { prevent(e); dropzone.classList.remove("dragover"); })
      );

      dropzone.addEventListener("drop", (e) => {
        const droppedFiles = e.dataTransfer?.files;
        if (!droppedFiles || droppedFiles.length === 0) return;
        
        // Get existing files
        const existingFiles = fileInput.files ? Array.from(fileInput.files) : [];
        const newFiles = Array.from(droppedFiles);
        
        // Combine existing and new files
        const allFiles = [...existingFiles, ...newFiles];
        
        // Check file count limit
        if (allFiles.length > 5) {
          showModal({ ok:false, text:`Maximum 5 files allowed. You have ${existingFiles.length} file(s) and tried to add ${newFiles.length}. Please drop fewer files.` });
          return;
        }
        
        // Validate new files only
        const invalidFiles = newFiles.filter(file => !isValidFileType(file));
        if (invalidFiles.length > 0) {
          showModal({ ok:false, text:`Unsupported file type: ${invalidFiles[0].name}. Please upload PDF, DOCX, or TXT files only.` });
          return;
        }
        
        // Add all files to input
        const dt = new DataTransfer();
        allFiles.forEach(file => dt.items.add(file));
        fileInput.files = dt.files;
        setFileLine(fileInput.files);
      });

      form.addEventListener("submit", async (e) => {
        e.preventDefault();

        if (!N8N_WEBHOOK_URL){
          showModal({ ok:false, text:"Webhook URL is not configured. Please contact support." });
          return;
        }

        // Check for existing processing job (pending is treated like processing)
        const existingJob = loadJob();
        if (existingJob && (existingJob.status === "processing" || existingJob.status === "pending") && !isJobExpired(existingJob)) {
          // Resume existing job: show loader and start status checking
          setLoading(true);
          startStatusInterval();
          // Immediately check status
          checkJobStatusOnce(existingJob.jobId).then(handleJobStatusUpdate);
          return;
        }

        // Clear any expired or terminal jobs
        if (existingJob) {
          if (isJobExpired(existingJob) || existingJob.status === "failed") {
            clearJob();
          }
          // If completed, keep it (user hasn't clicked Done yet)
        }

        // Validate links
        const isWebsiteLinkValid = validateWebsiteLink();
        const isLinkedInLinkValid = validateLinkedInLink();
        
        if (!isWebsiteLinkValid || !isLinkedInLinkValid) {
          return; // Validation errors are shown inline
        }

        const files = fileInput.files;
        
        // Files are optional, but if provided, validate them
        if (files && files.length > 0) {
          // Check file count limit
          if (files.length > 5) {
            showModal({ ok:false, text:"Maximum 5 files allowed. Please select fewer files." });
            return;
          }
          
          // Validate all files
          const invalidFiles = Array.from(files).filter(file => !isValidFileType(file));
          if (invalidFiles.length > 0) {
            showModal({ ok:false, text:`Unsupported file type: ${invalidFiles[0].name}. Please upload PDF, DOCX, or TXT files only.` });
            return;
          }
        }

        setLoading(true);

        try {
          const fd = new FormData();
          
          // Add form fields
          fd.append('websiteLink', form.websiteLink.value);
          if (form.linkedinLink.value) {
            fd.append('linkedinLink', form.linkedinLink.value);
          }
          
          // Add files if any (as array)
          if (files && files.length > 0) {
            // FormData with multiple files - each file is added with the same field name
            Array.from(files).forEach(file => {
              fd.append('file', file);
            });
          }
          // If no files, 'file' field is not added to FormData

          // Start job request (no Content-Type header for FormData)
          const res = await fetch(N8N_WEBHOOK_URL, { 
            method: "POST", 
            body: fd,
            mode: "cors",
            credentials: "omit"
          });

          if (!res.ok) {
            const errText = await res.text().catch(() => "");
            throw new Error(errText || `Request failed (${res.status})`);
          }

          const data = await res.json();
          
          // n8n returns a single object (or array with one object - handle both)
          let jobItem;
          if (Array.isArray(data)) {
            if (data.length === 0) {
              throw new Error("Invalid response format: empty array");
            }
            jobItem = data[0];
          } else if (data && typeof data === 'object') {
            jobItem = data;
          } else {
            throw new Error("Invalid response format: expected object or array with job object");
          }

          if (!jobItem.jobId) {
            throw new Error("Invalid job response: missing jobId");
          }

          // Default status to "pending" if not provided
          const jobStatus = jobItem.status || "pending";

          // Save job to localStorage
          saveJob({
            jobId: jobItem.jobId,
            status: jobStatus,
            createdAt: jobItem.createdAt || new Date().toISOString(),
            updatedAt: jobItem.updatedAt || jobItem.createdAt || new Date().toISOString()
          });

          // Start status checking interval
          startStatusInterval();

        } catch (err) {
          // Handle errors
          let errorMessage = err?.message || 'Unknown error occurred';
          
          if (err.message?.includes('Failed to fetch') || err.message?.includes('ERR_NETWORK')) {
            errorMessage = 'Network connection failed. Please check your connection and try again.';
          }
          
          showModal({ ok: false, text: `Error: ${errorMessage}` });
          setLoading(false);
        }
      });
    </script>
  </body>
</html>
