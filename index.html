<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CornerPXL Intelligence</title>
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <div class="wrap">
      <div class="hero">
        <h1 class="title">CornerPXL Intelligence</h1>
        <p class="subtitle">Paste links + upload context to generate brand, market, and strategy reports.</p>
      </div>

      <div class="panel">
        <form id="form">
          <div class="row">
            <div class="field">
              <div class="label">Website Link</div>
              <input class="input" type="url" name="websiteLink" id="websiteLink" placeholder="https://example.com" required />
              <div class="errorMsg hidden" id="websiteLinkError"></div>
            </div>
            <div class="field">
              <div class="label">LinkedIn Link</div>
              <input class="input" type="url" name="linkedinLink" id="linkedinLink" placeholder="https://linkedin.com/in/..." required />
              <div class="errorMsg hidden" id="linkedinLinkError"></div>
            </div>
          </div>

          <div class="drop" id="dropzone">
            <div class="dropInner">
              <div class="icon" aria-hidden="true">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
                  <path d="M12 3v10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M8 7l4-4 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M4 14v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
              </div>

              <p class="dropTitle">Drop files here</p>
              <p class="dropMeta">Supported formats: PDF, DOCX, TXT • Max size: 50MB per file • Up to 5 files</p>

              <div class="fileLine hidden" id="fileLine"></div>
              <div class="browse" id="browseBtn">Browse files</div>
            </div>

            <!-- IMPORTANT: field name is "file" -->
            <input id="fileInput" type="file" name="file" multiple accept=".pdf,.docx,.txt,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document,text/plain" />
          </div>

          <button id="analyzeBtn" class="cta" type="submit">
            <span id="ctaIcon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M12 3v10" stroke="white" stroke-width="2" stroke-linecap="round"/>
                <path d="M8 11l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M4 20h16" stroke="white" stroke-width="2" stroke-linecap="round"/>
              </svg>
            </span>
            <span id="ctaText">Generate Reports</span>
          </button>
        </form>
      </div>

      <div class="loadingInfo hidden" id="loadingInfo">
        <p>Usually takes up to 10 mins</p>
      </div>

      <div class="mini">
        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M12 3v10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M8 7l4-4 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 14v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </div>
          <h4>Easy Upload</h4>
          <p>Add a website link, optional LinkedIn, and any supporting files.</p>
        </div>

        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            </svg>
          </div>
          <h4>Fast Processing</h4>
          <p>We analyze your inputs and generate research + strategy documents automatically.</p>
        </div>

        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
              <path d="M14 2v6h6" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            </svg>
          </div>
          <h4>Instant Download</h4>
          <p>Download your Brand Research, Market Research, and Strategy Document when ready.</p>
        </div>
      </div>
    </div>

    <!-- RESULT MODAL -->
    <div id="overlay" class="overlay" role="dialog" aria-modal="true">
      <div class="modal">
        <div class="modalHeader">
          <div id="badge" class="badge">✓</div>
          <h3 id="modalTitle" class="modalTitle">Success</h3>
        </div>
        <p id="modalText" class="modalText"></p>

        <div id="downloadLinks" class="links hidden"></div>

        <div class="actions">
          <button id="okBtn" class="btn btnPrimary" type="button">Done</button>
        </div>
      </div>
    </div>

    <!-- Load configuration from config.js (can be generated from .env) -->
    <script src="config.js"></script>
    <script>
      // Get webhook URL from config or use default
      // NOTE: Webhook URL will be visible in browser. For production, consider:
      // 1. Adding authentication to n8n webhook
      // 2. Using a server-side proxy
      const N8N_WEBHOOK_URL = window.APP_CONFIG?.N8N_WEBHOOK_URL || null;

      const form = document.getElementById("form");
      const dropzone = document.getElementById("dropzone");
      const fileInput = document.getElementById("fileInput");
      const browseBtn = document.getElementById("browseBtn");
      const fileLine = document.getElementById("fileLine");
      
      const websiteLinkInput = document.getElementById("websiteLink");
      const linkedinLinkInput = document.getElementById("linkedinLink");
      const websiteLinkError = document.getElementById("websiteLinkError");
      const linkedinLinkError = document.getElementById("linkedinLinkError");

      const overlay = document.getElementById("overlay");
      const analyzeBtn = document.getElementById("analyzeBtn");
      const ctaText = document.getElementById("ctaText");
      const ctaIcon = document.getElementById("ctaIcon");

      const badge = document.getElementById("badge");
      const modalTitle = document.getElementById("modalTitle");
      const modalText = document.getElementById("modalText");
      const downloadLinks = document.getElementById("downloadLinks");
      const okBtn = document.getElementById("okBtn");
      const loadingInfo = document.getElementById("loadingInfo");

      function humanSize(bytes){
        const mb = bytes / (1024*1024);
        if (mb >= 1) return `${mb.toFixed(2)} MB`;
        const kb = bytes / 1024;
        return `${kb.toFixed(1)} KB`;
      }

      function isValidFileType(file){
        const allowedExtensions = ['.pdf', '.docx', '.txt'];
        const fileName = file.name.toLowerCase();
        return allowedExtensions.some(ext => fileName.endsWith(ext));
      }

      function isValidUrl(url, allowEmpty = false){
        if (!url || url.trim() === '') {
          return allowEmpty;
        }
        try {
          const urlObj = new URL(url);
          return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';
        } catch {
          return false;
        }
      }

      function isValidLinkedInUrl(url){
        if (!url || url.trim() === '') return false; // Required field
        const linkedinPattern = /^https?:\/\/(www\.)?linkedin\.com\/(in|company|school)\/.+/i;
        return linkedinPattern.test(url);
      }

      function showError(inputElement, errorElement, message){
        inputElement.classList.add('error');
        errorElement.textContent = message;
        errorElement.classList.remove('hidden');
      }

      function hideError(inputElement, errorElement){
        inputElement.classList.remove('error');
        errorElement.classList.add('hidden');
      }

      function validateWebsiteLink(){
        const value = websiteLinkInput.value.trim();
        if (!value) {
          showError(websiteLinkInput, websiteLinkError, 'Website link is required');
          return false;
        }
        if (!isValidUrl(value)) {
          showError(websiteLinkInput, websiteLinkError, 'Please enter a valid URL (e.g., https://example.com)');
          return false;
        }
        hideError(websiteLinkInput, websiteLinkError);
        return true;
      }

      function validateLinkedInLink(){
        const value = linkedinLinkInput.value.trim();
        if (!value) {
          showError(linkedinLinkInput, linkedinLinkError, 'LinkedIn link is required');
          return false;
        }
        if (!isValidUrl(value)) {
          showError(linkedinLinkInput, linkedinLinkError, 'Please enter a valid URL');
          return false;
        }
        if (!isValidLinkedInUrl(value)) {
          showError(linkedinLinkInput, linkedinLinkError, 'Please enter a valid LinkedIn URL (e.g., https://linkedin.com/in/username)');
          return false;
        }
        hideError(linkedinLinkInput, linkedinLinkError);
        return true;
      }

      function removeFile(indexToRemove){
        const files = fileInput.files;
        if (!files || files.length === 0) return;
        
        const dt = new DataTransfer();
        Array.from(files).forEach((file, index) => {
          if (index !== indexToRemove) {
            dt.items.add(file);
          }
        });
        fileInput.files = dt.files;
        setFileLine(fileInput.files);
      }

      function setFileLine(files){
        if (!files || files.length === 0){ 
          fileLine.classList.add("hidden"); 
          fileLine.innerHTML=""; 
          return; 
        }
        
        // Check file count limit
        if (files.length > 5) {
          fileLine.classList.remove("hidden");
          fileLine.innerHTML = `<span style="color: var(--error);">Maximum 5 files allowed. Please select fewer files.</span>`;
          fileInput.value = ''; // Clear the files
          return;
        }
        
        // Validate all files
        const invalidFiles = Array.from(files).filter(file => !isValidFileType(file));
        if (invalidFiles.length > 0) {
          fileLine.classList.remove("hidden");
          fileLine.innerHTML = `<span style="color: var(--error);">Unsupported file type: ${invalidFiles[0].name}. Please upload PDF, DOCX, or TXT files only.</span>`;
          fileInput.value = ''; // Clear the invalid files
          return;
        }
        
        // Display all files with remove buttons
        fileLine.classList.remove("hidden");
        const filesList = Array.from(files).map((file, index) => 
          `<div class="fileItem" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; padding: 6px 8px; background: rgba(173,216,230,0.1); border-radius: 8px;">
            <span>${index + 1}. ${file.name} <span style="color: var(--muted);">(${humanSize(file.size)})</span></span>
            <button type="button" class="removeFileBtn" data-index="${index}" aria-label="Remove file" style="background: none; border: none; color: var(--error); cursor: pointer; padding: 4px 8px; font-size: 18px; font-weight: 900; line-height: 1;">×</button>
          </div>`
        ).join('');
        fileLine.innerHTML = `<div style="text-align: left;">${filesList}</div>`;
        
        // Add event listeners to remove buttons
        fileLine.querySelectorAll('.removeFileBtn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const index = parseInt(btn.getAttribute('data-index'));
            removeFile(index);
          });
        });
      }

      function base64ToBlob(base64, mimeType = "application/pdf"){
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++){
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
      }

      function downloadBlob(blob, filename){
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      async function downloadFromUrl(url, filename){
        try {
          // Download from webhook
          // Webhook handles file access server-side and returns the file
          const response = await fetch(url, {
            method: 'POST',
            mode: 'cors',
            credentials: 'omit',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (!response.ok) {
            const errorText = await response.text().catch(() => '');
            console.error('Download failed:', response.status, errorText);
            
            if (response.status === 404) {
              showModal({ 
                ok: false, 
                text: `File not found: "${filename}". The file may have been moved or deleted.` 
              });
              return;
            }
            
            if (response.status === 403) {
              showModal({ 
                ok: false, 
                text: `Access denied: Unable to download "${filename}". Please contact support.` 
              });
              return;
            }
            
            throw new Error(`Failed to fetch: ${response.status}`);
          }
          
          // Get the blob and download
          const blob = await response.blob();
          downloadBlob(blob, filename);
          
        } catch (err) {
          console.error('Download error:', err);
          
          // Show user-friendly error message
          showModal({ 
            ok: false, 
            text: `Unable to download "${filename}": ${err.message || 'Network error'}. Please try again or contact support.` 
          });
        }
      }

      function setLoading(isLoading){
        analyzeBtn.disabled = isLoading;
        
        // Disable/enable all form inputs
        websiteLinkInput.disabled = isLoading;
        linkedinLinkInput.disabled = isLoading;
        fileInput.disabled = isLoading;
        
        // Disable dropzone interactions
        if (isLoading) {
          dropzone.style.pointerEvents = 'none';
          dropzone.style.opacity = '0.6';
        } else {
          dropzone.style.pointerEvents = 'auto';
          dropzone.style.opacity = '1';
        }
        
        // Show/hide loading info message
        if (loadingInfo) {
          if (isLoading) {
            loadingInfo.classList.remove('hidden');
            loadingInfo.style.display = 'block';
          } else {
            loadingInfo.classList.add('hidden');
            loadingInfo.style.display = 'none';
          }
        }
        
        if (isLoading){
          ctaText.textContent = "Analyzing...";
          ctaIcon.innerHTML = '<div class="spinner" aria-hidden="true"></div>';
        } else {
          ctaText.textContent = "Generate Reports";
          ctaIcon.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
              <path d="M12 3v10" stroke="white" stroke-width="2" stroke-linecap="round"/>
              <path d="M8 11l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 20h16" stroke="white" stroke-width="2" stroke-linecap="round"/>
            </svg>`;
        }
      }

      function showModal({ ok, text, links }){
        overlay.classList.add("show");
        badge.className = "badge";
        if (ok){
          badge.textContent = "✓";
          badge.classList.add("success");
          modalTitle.textContent = "Success";
          modalText.textContent = text || "Your reports are ready.";
        } else {
          badge.textContent = "!";
          badge.classList.add("error");
          modalTitle.textContent = "Error";
          modalText.textContent = text || "Something went wrong.";
        }

        downloadLinks.innerHTML = "";
        if (Array.isArray(links) && links.length){
          downloadLinks.classList.remove("hidden");
          links.forEach((r, index) => {
            const a = document.createElement("a");
            a.className = "linkBtn";
            const filename = r.name || `report-${index + 1}.pdf`;
            const url = r.url;
            
            // Handle click to force download
            a.addEventListener("click", async (e) => {
              e.preventDefault();
              
              // If it's already a blob URL, download directly
              if (url.startsWith('blob:')) {
                const response = await fetch(url);
                const blob = await response.blob();
                downloadBlob(blob, filename);
                return;
              }
              
              // For external URLs, fetch and download
              await downloadFromUrl(url, filename);
            });
            
            a.href = url;
            a.download = filename;
            a.rel = "noopener";
            a.innerHTML = `<span>${r.name || `Report ${index + 1}`}</span><small>Download</small>`;
            downloadLinks.appendChild(a);
          });
        } else {
          downloadLinks.classList.add("hidden");
        }
      }

      function resetFlow(){
        overlay.classList.remove("show");
        form.reset();
        setFileLine(null);
        setLoading(false);
        // Clear validation errors
        hideError(websiteLinkInput, websiteLinkError);
        hideError(linkedinLinkInput, linkedinLinkError);
      }
      okBtn.addEventListener("click", resetFlow);

      // Link validation event listeners
      websiteLinkInput.addEventListener("blur", validateWebsiteLink);
      websiteLinkInput.addEventListener("input", () => {
        if (websiteLinkInput.classList.contains('error')) {
          validateWebsiteLink();
        }
      });

      linkedinLinkInput.addEventListener("blur", validateLinkedInLink);
      linkedinLinkInput.addEventListener("input", () => {
        if (linkedinLinkInput.classList.contains('error')) {
          validateLinkedInLink();
        }
      });

      browseBtn.addEventListener("click", (e) => { e.preventDefault(); fileInput.click(); });
      dropzone.addEventListener("click", (e) => {
        if (e.target?.closest?.("#browseBtn")) return;
        fileInput.click();
      });

      fileInput.addEventListener("change", () => setFileLine(fileInput.files || null));

      function prevent(e){ e.preventDefault(); e.stopPropagation(); }

      ["dragenter","dragover"].forEach(evt =>
        dropzone.addEventListener(evt, (e) => { prevent(e); dropzone.classList.add("dragover"); })
      );
      ["dragleave","drop"].forEach(evt =>
        dropzone.addEventListener(evt, (e) => { prevent(e); dropzone.classList.remove("dragover"); })
      );

      dropzone.addEventListener("drop", (e) => {
        const droppedFiles = e.dataTransfer?.files;
        if (!droppedFiles || droppedFiles.length === 0) return;
        
        // Get existing files
        const existingFiles = fileInput.files ? Array.from(fileInput.files) : [];
        const newFiles = Array.from(droppedFiles);
        
        // Combine existing and new files
        const allFiles = [...existingFiles, ...newFiles];
        
        // Check file count limit
        if (allFiles.length > 5) {
          showModal({ ok:false, text:`Maximum 5 files allowed. You have ${existingFiles.length} file(s) and tried to add ${newFiles.length}. Please drop fewer files.` });
          return;
        }
        
        // Validate new files only
        const invalidFiles = newFiles.filter(file => !isValidFileType(file));
        if (invalidFiles.length > 0) {
          showModal({ ok:false, text:`Unsupported file type: ${invalidFiles[0].name}. Please upload PDF, DOCX, or TXT files only.` });
          return;
        }
        
        // Add all files to input
        const dt = new DataTransfer();
        allFiles.forEach(file => dt.items.add(file));
        fileInput.files = dt.files;
        setFileLine(fileInput.files);
      });

      form.addEventListener("submit", async (e) => {
        e.preventDefault();

        if (!N8N_WEBHOOK_URL){
          showModal({ ok:false, text:"Webhook URL is not configured. Please contact support." });
          return;
        }

        // Validate links
        const isWebsiteLinkValid = validateWebsiteLink();
        const isLinkedInLinkValid = validateLinkedInLink();
        
        if (!isWebsiteLinkValid || !isLinkedInLinkValid) {
          return; // Validation errors are shown inline
        }

        const files = fileInput.files;
        
        // Files are optional, but if provided, validate them
        if (files && files.length > 0) {
          // Check file count limit
          if (files.length > 5) {
            showModal({ ok:false, text:"Maximum 5 files allowed. Please select fewer files." });
            return;
          }
          
          // Validate all files
          const invalidFiles = Array.from(files).filter(file => !isValidFileType(file));
          if (invalidFiles.length > 0) {
            showModal({ ok:false, text:`Unsupported file type: ${invalidFiles[0].name}. Please upload PDF, DOCX, or TXT files only.` });
            return;
          }
        }

        setLoading(true);

        // Declare cleanup variables outside try block so they're accessible in catch
        let timeoutId;
        let controller;

        try{
          const fd = new FormData();
          
          // Add form fields
          fd.append('websiteLink', form.websiteLink.value);
          if (form.linkedinLink.value) {
            fd.append('linkedinLink', form.linkedinLink.value);
          }
          
          // Add files if any (as array)
          const files = fileInput.files;
          if (files && files.length > 0) {
            // FormData with multiple files - each file is added with the same field name
            Array.from(files).forEach(file => {
              fd.append('file', file);
            });
          }
          // If no files, 'file' field is not added to FormData

          // Create AbortController with extended timeout (15 minutes to account for processing time)
          controller = new AbortController();
          timeoutId = setTimeout(() => controller.abort(), 15 * 60 * 1000); // 15 minutes

          const res = await fetch(N8N_WEBHOOK_URL, { 
            method:"POST", 
            body: fd,
            signal: controller.signal,
            keepalive: true // Helps prevent suspension
          });

          // Clear timeout on success
          clearTimeout(timeoutId);

          if (!res.ok){
            const errText = await res.text().catch(()=>"");
            throw new Error(errText || `Request failed (${res.status})`);
          }

          const ct = (res.headers.get("content-type") || "").toLowerCase();

          // A) ZIP/binary
          if (ct.includes("application/zip") || ct.includes("application/octet-stream")){
            const blob = await res.blob();
            downloadBlob(blob, "reports.zip");
            showModal({ ok:true, text:"Done! Report download will start now." });
            return;
          }

          // B) JSON with URLs or file URLs
          if (ct.includes("application/json")){
            const data = await res.json();
            if (!data?.ok) throw new Error(data?.error || "Workflow returned ok=false");
            
            // Processing results: can be array of files or array of URLs
            let reports = [];
            if (data.results && Array.isArray(data.results)){
              reports = data.results.map((result, index) => {
                // If this is a base64 file
                if (result.base64 && result.filename){
                  const blob = base64ToBlob(result.base64, result.mimeType || "application/pdf");
                  const url = URL.createObjectURL(blob);
                  return {
                    name: result.filename,
                    url: url
                  };
                }
                // If this is a URL
                if (result.url){
                  // Generate friendly name from result.name
                  let displayName = result.name;
                  if (result.name === 'brandResearch') {
                    displayName = 'Brand Research';
                  } else if (result.name === 'marketResearch') {
                    displayName = 'Market Research';
                  } else if (result.name === 'strategyBrief') {
                    displayName = 'Strategy Brief';
                  }
                  
                  return {
                    name: displayName || result.name || result.filename || `Report ${index + 1}.pdf`,
                    url: result.url
                  };
                }
                // If this is just a string (URL)
                if (typeof result === "string"){
                  return {
                    name: `Report ${index + 1}.pdf`,
                    url: result
                  };
                }
                return result;
              });
            }
            
            // Auto-download files if they are blob URLs
            reports.forEach((report, index) => {
              if (report.url && report.url.startsWith('blob:')){
                // This is a blob URL, auto-downloading
                setTimeout(() => {
                  const a = document.createElement("a");
                  a.href = report.url;
                  a.download = report.name || `report-${index + 1}.pdf`;
                  document.body.appendChild(a);
                  a.click();
                  a.remove();
                }, index * 300); // Delay between downloads
              }
            });
            
            showModal({
              ok:true,
              text: reports.length > 0 
                ? `Done! ${reports.length} report${reports.length > 1 ? 's' : ''} ${reports.length > 1 ? 'are' : 'is'} downloading automatically. You can also download them below.`
                : "Done! Your reports have been processed.",
              links: reports
            });
            return;
          }

          // fallback
          const text = await res.text();
          showModal({ ok:true, text:`Success (unexpected response): ${text.slice(0, 180)}...` });

        } catch (err){
          // Always cleanup timeout on error
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          
          // Handle specific error types
          let errorMessage = err?.message || 'Unknown error occurred';
          
          if (err.name === 'AbortError') {
            errorMessage = 'Request timed out after 15 minutes. The processing may still be running. Please try again or contact support.';
          } else if (err.message?.includes('Failed to fetch') || err.message?.includes('ERR_NETWORK')) {
            errorMessage = 'Network connection was interrupted. This can happen if the browser tab becomes inactive. Please try again and keep the tab active during processing.';
          } else if (err.message?.includes('suspended') || err.message?.includes('SUSPENDED')) {
            errorMessage = 'Network request was suspended. Please keep this browser tab active and try again.';
          }
          
          showModal({ ok:false, text: `Error: ${errorMessage}` });
        } finally {
          setLoading(false);
        }
      });
    </script>
  </body>
</html>
