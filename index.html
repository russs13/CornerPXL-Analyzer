<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CornerPXL Intelligence</title>
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <div class="wrap">
      <div class="hero">
        <h1 class="title">CornerPXL Intelligence</h1>
        <p class="subtitle">Paste links + upload context to generate brand, market, and strategy reports.</p>
      </div>

      <!-- Test Mode Toggle -->
      <div class="testMode">
        <label class="testToggle">
          <input type="checkbox" id="mockModeToggle" />
          <span>Test Mode (Mock Responses)</span>
        </label>
        <div class="testOptions" id="testOptions" style="display: none;">
          <label class="testRadio">
            <input type="radio" name="mockResponse" value="success" checked />
            <span>Success Response</span>
          </label>
          <label class="testRadio">
            <input type="radio" name="mockResponse" value="error" />
            <span>Error Response</span>
          </label>
        </div>
      </div>

      <div class="panel">
        <form id="form">
          <div class="row">
            <div class="field">
              <div class="label">Website Link</div>
              <input class="input" type="url" name="websiteLink" id="websiteLink" placeholder="https://example.com" required />
              <div class="errorMsg hidden" id="websiteLinkError"></div>
            </div>
            <div class="field">
              <div class="label">LinkedIn Link</div>
              <input class="input" type="url" name="linkedinLink" id="linkedinLink" placeholder="https://linkedin.com/in/..." />
              <div class="errorMsg hidden" id="linkedinLinkError"></div>
            </div>
          </div>

          <div class="drop" id="dropzone">
            <div class="dropInner">
              <div class="icon" aria-hidden="true">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
                  <path d="M12 3v10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M8 7l4-4 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M4 14v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
              </div>

              <p class="dropTitle">Drop file here</p>
              <p class="dropMeta">Supported formats: PDF, DOC/DOCX, TXT • Max size: 50MB</p>

              <div class="fileLine hidden" id="fileLine"></div>
              <div class="browse" id="browseBtn">Browse file</div>
            </div>

            <!-- IMPORTANT: field name is "file" -->
            <input id="fileInput" type="file" name="file" accept=".pdf,.doc,.docx,.txt,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,text/plain" />
          </div>

          <button id="analyzeBtn" class="cta" type="submit">
            <span id="ctaIcon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M12 3v10" stroke="white" stroke-width="2" stroke-linecap="round"/>
                <path d="M8 11l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M4 20h16" stroke="white" stroke-width="2" stroke-linecap="round"/>
              </svg>
            </span>
            <span id="ctaText">Generate Reports</span>
          </button>
        </form>
      </div>

      <div class="mini">
        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M12 3v10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M8 7l4-4 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 14v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </div>
          <h4>Easy Upload</h4>
          <p>Add a website link, optional LinkedIn, and any supporting files.</p>
        </div>

        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            </svg>
          </div>
          <h4>Fast Processing</h4>
          <p>We analyze your inputs and generate research + strategy documents automatically.</p>
        </div>

        <div class="miniCard">
          <div class="icon center">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
              <path d="M14 2v6h6" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            </svg>
          </div>
          <h4>Instant Download</h4>
          <p>Download your Brand Research, Market Research, and Strategy Document when ready.</p>
        </div>
      </div>
    </div>

    <!-- RESULT MODAL -->
    <div id="overlay" class="overlay" role="dialog" aria-modal="true">
      <div class="modal">
        <div class="modalHeader">
          <div id="badge" class="badge">✓</div>
          <h3 id="modalTitle" class="modalTitle">Success</h3>
        </div>
        <p id="modalText" class="modalText"></p>

        <div id="downloadLinks" class="links hidden"></div>

        <div class="actions">
          <button id="okBtn" class="btn btnPrimary" type="button">Done</button>
        </div>
      </div>
    </div>

    <!-- Load configuration from config.js (can be generated from .env) -->
    <script src="config.js"></script>
    <script>
      // Get webhook URL from config or use default
      // NOTE: Webhook URL will be visible in browser. For production, consider:
      // 1. Adding authentication to n8n webhook
      // 2. Using a server-side proxy
      const N8N_WEBHOOK_URL = window.APP_CONFIG?.N8N_WEBHOOK_URL || null;

      const form = document.getElementById("form");
      const dropzone = document.getElementById("dropzone");
      const fileInput = document.getElementById("fileInput");
      const browseBtn = document.getElementById("browseBtn");
      const fileLine = document.getElementById("fileLine");
      
      const websiteLinkInput = document.getElementById("websiteLink");
      const linkedinLinkInput = document.getElementById("linkedinLink");
      const websiteLinkError = document.getElementById("websiteLinkError");
      const linkedinLinkError = document.getElementById("linkedinLinkError");

      const overlay = document.getElementById("overlay");
      const analyzeBtn = document.getElementById("analyzeBtn");
      const ctaText = document.getElementById("ctaText");
      const ctaIcon = document.getElementById("ctaIcon");

      const badge = document.getElementById("badge");
      const modalTitle = document.getElementById("modalTitle");
      const modalText = document.getElementById("modalText");
      const downloadLinks = document.getElementById("downloadLinks");
      const okBtn = document.getElementById("okBtn");

      const mockModeToggle = document.getElementById("mockModeToggle");
      const testOptions = document.getElementById("testOptions");

      function humanSize(bytes){
        const mb = bytes / (1024*1024);
        if (mb >= 1) return `${mb.toFixed(2)} MB`;
        const kb = bytes / 1024;
        return `${kb.toFixed(1)} KB`;
      }

      function isValidFileType(file){
        const allowedExtensions = ['.pdf', '.doc', '.docx', '.txt'];
        const fileName = file.name.toLowerCase();
        return allowedExtensions.some(ext => fileName.endsWith(ext));
      }

      function isValidUrl(url, allowEmpty = false){
        if (!url || url.trim() === '') {
          return allowEmpty;
        }
        try {
          const urlObj = new URL(url);
          return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';
        } catch {
          return false;
        }
      }

      function isValidLinkedInUrl(url){
        if (!url || url.trim() === '') return true; // Optional field
        const linkedinPattern = /^https?:\/\/(www\.)?linkedin\.com\/(in|company|school)\/.+/i;
        return linkedinPattern.test(url);
      }

      function showError(inputElement, errorElement, message){
        inputElement.classList.add('error');
        errorElement.textContent = message;
        errorElement.classList.remove('hidden');
      }

      function hideError(inputElement, errorElement){
        inputElement.classList.remove('error');
        errorElement.classList.add('hidden');
      }

      function validateWebsiteLink(){
        const value = websiteLinkInput.value.trim();
        if (!value) {
          showError(websiteLinkInput, websiteLinkError, 'Website link is required');
          return false;
        }
        if (!isValidUrl(value)) {
          showError(websiteLinkInput, websiteLinkError, 'Please enter a valid URL (e.g., https://example.com)');
          return false;
        }
        hideError(websiteLinkInput, websiteLinkError);
        return true;
      }

      function validateLinkedInLink(){
        const value = linkedinLinkInput.value.trim();
        if (!value) {
          hideError(linkedinLinkInput, linkedinLinkError);
          return true; // Optional field
        }
        if (!isValidUrl(value)) {
          showError(linkedinLinkInput, linkedinLinkError, 'Please enter a valid URL');
          return false;
        }
        if (!isValidLinkedInUrl(value)) {
          showError(linkedinLinkInput, linkedinLinkError, 'Please enter a valid LinkedIn URL (e.g., https://linkedin.com/in/username)');
          return false;
        }
        hideError(linkedinLinkInput, linkedinLinkError);
        return true;
      }

      function setFileLine(file){
        if (!file){ fileLine.classList.add("hidden"); fileLine.innerHTML=""; return; }
        
        if (!isValidFileType(file)){
          fileLine.classList.remove("hidden");
          fileLine.innerHTML = `<span style="color: var(--error);">Unsupported file type. Please upload PDF, DOC/DOCX, or TXT files only.</span>`;
          fileInput.value = ''; // Clear the invalid file
          return;
        }
        
        fileLine.classList.remove("hidden");
        fileLine.innerHTML = `${file.name} <span>(${humanSize(file.size)})</span>`;
      }

      function base64ToBlob(base64, mimeType = "application/pdf"){
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++){
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
      }

      function downloadBlob(blob, filename){
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      async function downloadFromUrl(url, filename){
        try {
          const response = await fetch(url, {
            mode: 'cors',
            credentials: 'omit'
          });
          if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
          const blob = await response.blob();
          downloadBlob(blob, filename);
        } catch (err) {
          console.error('Download error (CORS or network):', err);
          
          // For CORS-restricted files, we can't force download from client-side JavaScript
          // Try to use download attribute (works for same-origin, may work for some servers)
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          document.body.appendChild(a);
          a.click();
          a.remove();
          
          // If download attribute didn't work (CORS issue), the file will open in new tab
          // User can use browser's "Save As" if needed
        }
      }

      function setLoading(isLoading){
        analyzeBtn.disabled = isLoading;
        if (isLoading){
          ctaText.textContent = "Analyzing...";
          ctaIcon.innerHTML = '<div class="spinner" aria-hidden="true"></div>';
        } else {
          ctaText.textContent = "Generate Reports";
          ctaIcon.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
              <path d="M12 3v10" stroke="white" stroke-width="2" stroke-linecap="round"/>
              <path d="M8 11l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 20h16" stroke="white" stroke-width="2" stroke-linecap="round"/>
            </svg>`;
        }
      }

      function showModal({ ok, text, links }){
        overlay.classList.add("show");
        badge.className = "badge";
        if (ok){
          badge.textContent = "✓";
          badge.classList.add("success");
          modalTitle.textContent = "Success";
          modalText.textContent = text || "Your reports are ready.";
        } else {
          badge.textContent = "!";
          badge.classList.add("error");
          modalTitle.textContent = "Error";
          modalText.textContent = text || "Something went wrong.";
        }

        downloadLinks.innerHTML = "";
        if (Array.isArray(links) && links.length){
          downloadLinks.classList.remove("hidden");
          links.forEach((r, index) => {
            const a = document.createElement("a");
            a.className = "linkBtn";
            const filename = r.name || `report-${index + 1}.pdf`;
            const url = r.url;
            
            // Handle click to force download
            a.addEventListener("click", async (e) => {
              e.preventDefault();
              
              // If it's already a blob URL, download directly
              if (url.startsWith('blob:')) {
                const response = await fetch(url);
                const blob = await response.blob();
                downloadBlob(blob, filename);
                return;
              }
              
              // For external URLs, fetch and download
              await downloadFromUrl(url, filename);
            });
            
            a.href = url;
            a.download = filename;
            a.rel = "noopener";
            a.innerHTML = `<span>${r.name || `Report ${index + 1}`}</span><small>Download</small>`;
            downloadLinks.appendChild(a);
          });
        } else {
          downloadLinks.classList.add("hidden");
        }
      }

      function resetFlow(){
        overlay.classList.remove("show");
        form.reset();
        setFileLine(null);
        setLoading(false);
        // Clear validation errors
        hideError(websiteLinkInput, websiteLinkError);
        hideError(linkedinLinkInput, linkedinLinkError);
      }
      okBtn.addEventListener("click", resetFlow);

      // Test mode toggle
      mockModeToggle.addEventListener("change", (e) => {
        testOptions.style.display = e.target.checked ? "flex" : "none";
      });

      // Link validation event listeners
      websiteLinkInput.addEventListener("blur", validateWebsiteLink);
      websiteLinkInput.addEventListener("input", () => {
        if (websiteLinkInput.classList.contains('error')) {
          validateWebsiteLink();
        }
      });

      linkedinLinkInput.addEventListener("blur", validateLinkedInLink);
      linkedinLinkInput.addEventListener("input", () => {
        if (linkedinLinkInput.classList.contains('error')) {
          validateLinkedInLink();
        }
      });

      browseBtn.addEventListener("click", (e) => { e.preventDefault(); fileInput.click(); });
      dropzone.addEventListener("click", (e) => {
        if (e.target?.closest?.("#browseBtn")) return;
        fileInput.click();
      });

      fileInput.addEventListener("change", () => setFileLine(fileInput.files?.[0] || null));

      function prevent(e){ e.preventDefault(); e.stopPropagation(); }

      ["dragenter","dragover"].forEach(evt =>
        dropzone.addEventListener(evt, (e) => { prevent(e); dropzone.classList.add("dragover"); })
      );
      ["dragleave","drop"].forEach(evt =>
        dropzone.addEventListener(evt, (e) => { prevent(e); dropzone.classList.remove("dragover"); })
      );

      dropzone.addEventListener("drop", (e) => {
        const file = e.dataTransfer?.files?.[0];
        if (!file) return;
        
        if (!isValidFileType(file)){
          showModal({ ok:false, text:"Unsupported file type. Please upload PDF, DOC/DOCX, or TXT files only." });
          return;
        }
        
        const dt = new DataTransfer();
        dt.items.add(file);
        fileInput.files = dt.files;
        setFileLine(file);
      });

      form.addEventListener("submit", async (e) => {
        e.preventDefault();

        // Check if mock mode is enabled
        const isMockMode = mockModeToggle?.checked;

        // Only check webhook URL if not in mock mode
        if (!isMockMode && !N8N_WEBHOOK_URL){
          showModal({ ok:false, text:"Webhook URL is not configured. Please contact support." });
          return;
        }

        // Validate links
        const isWebsiteLinkValid = validateWebsiteLink();
        const isLinkedInLinkValid = validateLinkedInLink();
        
        if (!isWebsiteLinkValid || !isLinkedInLinkValid) {
          return; // Validation errors are shown inline
        }

        const file = fileInput.files?.[0];
        if (!file){
          showModal({ ok:false, text:"Please upload a file." });
          return;
        }

        if (!isValidFileType(file)){
          showModal({ ok:false, text:"Unsupported file type. Please upload PDF, DOC/DOCX, or TXT files only." });
          return;
        }

        setLoading(true);

        try{
          const mockResponseType = document.querySelector('input[name="mockResponse"]:checked')?.value || 'success';

          if (isMockMode) {
            // Simulate network delay (2 seconds)
            await new Promise(resolve => setTimeout(resolve, 2000));

            if (mockResponseType === 'error') {
              // Mock error response
              const errorData = {
                error: "Cannot read properties of undefined (reading 'split')"
              };
              throw new Error(errorData.error);
            } else {
              // Mock success response
              const successData = {
                "ok": true,
                "reports": [
                  { "name": "report-1.pdf", "url": "https://filesamples.com/samples/document/txt/sample1.txt" },
                  { "name": "report-2.csv", "url": "https://filesamples.com/samples/document/txt/sample2.txt" },
                  { "name": "report-3.pdf", "url": "https://filesamples.com/samples/document/txt/sample3.txt" }
              ]
              };

              // Process mock success response
              let reports = [];
              if (successData.reports && Array.isArray(successData.reports)){
                reports = successData.reports.map((report, index) => {
                  if (report.url){
                    return {
                      name: report.name || `Report ${index + 1}.pdf`,
                      url: report.url
                    };
                  }
                  return report;
                });
              }

              showModal({
                ok: true,
                text: reports.length > 0 
                  ? `Done! ${reports.length} report${reports.length > 1 ? 's' : ''} ${reports.length > 1 ? 'are' : 'is'} ready. You can download them below.`
                  : "Done! Your reports have been processed.",
                links: reports
              });
              setLoading(false);
              return;
            }
          }

          // Ensure webhook is not called when mock mode is enabled
          if (isMockMode) {
            return; // Already handled above, this is a safety guard
          }

          const fd = new FormData(form); // includes websiteLink, linkedinLink, file

          const res = await fetch(N8N_WEBHOOK_URL, { method:"POST", body: fd });

          if (!res.ok){
            const errText = await res.text().catch(()=>"");
            throw new Error(errText || `Request failed (${res.status})`);
          }

          const ct = (res.headers.get("content-type") || "").toLowerCase();

          // A) ZIP/binary
          if (ct.includes("application/zip") || ct.includes("application/octet-stream")){
            const blob = await res.blob();
            downloadBlob(blob, "reports.zip");
            showModal({ ok:true, text:"Done! Report download will start now." });
            return;
          }

          // B) JSON with URLs or file URLs
          if (ct.includes("application/json")){
            const data = await res.json();
            if (!data?.ok) throw new Error(data?.error || "Workflow returned ok=false");
            
            // Processing reports: can be array of files or array of URLs
            let reports = [];
            if (data.reports && Array.isArray(data.reports)){
              reports = data.reports.map((report, index) => {
                // If this is a base64 file
                if (report.base64 && report.filename){
                  const blob = base64ToBlob(report.base64, report.mimeType || "application/pdf");
                  const url = URL.createObjectURL(blob);
                  return {
                    name: report.filename,
                    url: url
                  };
                }
                // If this is a URL
                if (report.url){
                  return {
                    name: report.name || report.filename || `Report ${index + 1}.pdf`,
                    url: report.url
                  };
                }
                // If this is just a string (URL)
                if (typeof report === "string"){
                  return {
                    name: `Report ${index + 1}.pdf`,
                    url: report
                  };
                }
                return report;
              });
            }
            
            // Auto-download files if they are blob URLs
            reports.forEach((report, index) => {
              if (report.url && report.url.startsWith('blob:')){
                // This is a blob URL, auto-downloading
                setTimeout(() => {
                  const a = document.createElement("a");
                  a.href = report.url;
                  a.download = report.name || `report-${index + 1}.pdf`;
                  document.body.appendChild(a);
                  a.click();
                  a.remove();
                }, index * 300); // Delay between downloads
              }
            });
            
            showModal({
              ok:true,
              text: reports.length > 0 
                ? `Done! ${reports.length} report${reports.length > 1 ? 's' : ''} ${reports.length > 1 ? 'are' : 'is'} downloading automatically. You can also download them below.`
                : "Done! Your reports have been processed.",
              links: reports
            });
            return;
          }

          // fallback
          const text = await res.text();
          showModal({ ok:true, text:`Success (unexpected response): ${text.slice(0, 180)}...` });

        } catch (err){
          showModal({ ok:false, text: `Error: ${err?.message || err}` });
        } finally {
          setLoading(false);
        }
      });
    </script>
  </body>
</html>
